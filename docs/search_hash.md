# Алгоритмы поиска и хеш-таблицы

## Описание

Этот проект посвящен реализации и сравнению различных алгоритмов поиска в отсортированных массивах, а также реализации различных методов хеширования для организации данных.

## Реализованные алгоритмы поиска

### 1. Бинарный поиск (Binary Search)
- **Сложность времени**: O(log n)
- **Сложность памяти**: O(1)
- **Описание**: Эффективный алгоритм поиска в отсортированном массиве. Работает путем деления массива пополам и сравнения искомого элемента с элементом в середине.

### 2. Поиск в бинарном дереве (Binary Tree Search)
- **Сложность времени**: O(log n) в среднем, O(n) в худшем случае
- **Сложность памяти**: O(n)
- **Описание**: Поиск в бинарном дереве поиска, где для каждого узла все элементы левого поддерева меньше, а правого - больше.

### 3. Фибоначчиев поиск (Fibonacci Search)
- **Сложность времени**: O(log n)
- **Сложность памяти**: O(1)
- **Описание**: Вариант бинарного поиска, использующий числа Фибоначчи для определения позиций деления массива.

### 4. Интерполяционный поиск (Interpolation Search)
- **Сложность времени**: O(log log n) в среднем, O(n) в худшем случае
- **Сложность памяти**: O(1)
- **Описание**: Улучшенная версия бинарного поиска, использующая интерполяцию для определения позиции искомого элемента.

## Реализованные методы хеширования

### 1. Простое рехэширование (Linear Probing)
- **Сложность времени**: O(1) в среднем, O(n) в худшем случае
- **Сложность памяти**: O(n)
- **Описание**: При коллизии следующий свободный слот ищется линейно.

**Метод хеширования**: `h(key) = key % size`

### 2. Рехэширование с помощью псевдослучайных чисел
- **Сложность времени**: O(1) в среднем, O(n) в худшем случае
- **Сложность памяти**: O(n)
- **Описание**: При коллизии используется псевдослучайный шаг для поиска следующей позиции.

**Метод хеширования**: `h(key) = key % size`, шаг: `(key * random) % size`

### 3. Метод цепочек (Chaining)
- **Сложность времени**: O(1) в среднем, O(n) в худшем случае
- **Сложность памяти**: O(n)
- **Описание**: Каждая ячейка хеш-таблицы содержит список элементов с одинаковым хешем.

**Метод хеширования**: `h(key) = key % size`

## Дополнительные задачи

### Задача о 8 ферзях
Реализован алгоритм решения задачи о размещении 8 ферзей на шахматной доске так, чтобы они не атаковали друг друга.

**Алгоритм**: Backtracking (поиск с возвратом)

## Структура файлов

- `search_hash.ipynb` - Jupyter notebook со всеми реализациями алгоритмов поиска и хеш-таблиц

## Использование

Откройте `search_hash.ipynb` в Jupyter Notebook и выполните ячейки по порядку. Каждая секция содержит реализацию алгоритма:
- Реализацию алгоритма
- Тестирование на случайных данных
- Измерение времени выполнения
- Сравнение с другими методами

## Сравнение алгоритмов поиска

| Алгоритм | Лучший случай | Средний случай | Худший случай | Память |
|----------|---------------|----------------|---------------|--------|
| Бинарный поиск | O(1) | O(log n) | O(log n) | O(1) |
| Бинарное дерево | O(1) | O(log n) | O(n) | O(n) |
| Фибоначчиев поиск | O(1) | O(log n) | O(log n) | O(1) |
| Интерполяционный | O(1) | O(log log n) | O(n) | O(1) |

## Сравнение методов хеширования

| Метод | Среднее время поиска | Худшее время | Память | Особенности |
|-------|---------------------|-------------|--------|-------------|
| Простое рехэширование | O(1) | O(n) | O(n) | Простота реализации |
| Псевдослучайное рехэширование | O(1) | O(n) | O(n) | Лучшее распределение |
| Метод цепочек | O(1) | O(n) | O(n) | Нет ограничения на размер |

## Зависимости

- Стандартная библиотека Python
- `time` - для измерения времени выполнения
- `random` - для генерации тестовых данных

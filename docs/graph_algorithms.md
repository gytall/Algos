# Сетевые алгоритмы. Динамические алгоритмы поиска путей

## Описание

Этот проект посвящен реализации алгоритмов поиска кратчайшего пути в ориентированных взвешенных графах. Реализованы различные алгоритмы с графической визуализацией и анализом временной сложности.

## Реализованные алгоритмы

### 1. Алгоритм Беллмана-Форда
- **Сложность времени**: O(V × E), где V - количество вершин, E - количество ребер
- **Сложность памяти**: O(V)
- **Описание**: Находит кратчайшие пути от одной вершины до всех остальных. Может обрабатывать графы с отрицательными весами ребер и обнаруживать отрицательные циклы.

### 2. Алгоритм Дейкстры
- **Сложность времени**: O((V + E) log V) с использованием кучи
- **Сложность памяти**: O(V)
- **Описание**: Эффективный алгоритм для поиска кратчайшего пути от начальной вершины до всех остальных в графе с неотрицательными весами.

### 3. Алгоритм Флойда-Уоршелла
- **Сложность времени**: O(V³)
- **Сложность памяти**: O(V²)
- **Описание**: Находит кратчайшие пути между всеми парами вершин в графе. Может обрабатывать отрицательные веса, но не отрицательные циклы.

### 4. Алгоритм Джонсона
- **Сложность времени**: O(V² log V + V × E)
- **Сложность памяти**: O(V²)
- **Описание**: Комбинирует алгоритм Беллмана-Форда и Дейкстры для поиска кратчайших путей между всеми парами вершин в разреженных графах.

### 5. Алгоритм Левита
- **Сложность времени**: O(V × E) в худшем случае
- **Сложность памяти**: O(V)
- **Описание**: Модификация алгоритма Беллмана-Форда, использующая приоритетную очередь для оптимизации.

### 6. Алгоритм Йена
- **Сложность времени**: O(k × V × (E + V log V))
- **Сложность памяти**: O(k × V)
- **Описание**: Находит k кратчайших путей между двумя вершинами в графе.

## Функциональность

### Ввод графа
Граф может быть задан:
- В виде матрицы смежности/инцидентности из файла
- Графически через пользовательский интерфейс

### Визуализация
Разработан графический интерфейс с визуализацией:
- Графа с весами ребер
- Кратчайшего пути между заданными вершинами (выделяется красным цветом)

### Анализ сложности
По результатам работы представлен анализ временной сложности алгоритмов в зависимости от:
- Количества вершин
- Количества ребер

Данные представлены в виде таблицы.

## Структура файлов

- `graph_algorithms.ipynb` - Jupyter notebook со всеми реализациями алгоритмов на графах
- `requirements.txt` - зависимости проекта

## Использование

1. Установите зависимости:
```bash
pip install -r requirements.txt
```

2. Откройте `graph_algorithms.ipynb` в Jupyter Notebook для работы с алгоритмами

3. Выполните ячейки по порядку:
   - Загрузите граф из файла или создайте его программно
   - Выберите начальную и конечную вершины
   - Запустите нужный алгоритм
   - Просмотрите визуализацию и результаты анализа

## Формат входного файла

Граф может быть представлен в двух форматах:

1. **Список ребер** (u v weight):
```
1 2 4
2 3 5
3 1 2
```

2. **Матрица смежности**:
```
0 4 INF
INF 0 5
2 INF 0
```

## Зависимости

- `networkx` - для работы с графами
- `matplotlib` - для визуализации
- `numpy` - для работы с матрицами
- `pandas` - для анализа данных
- `tabulate` - для форматирования таблиц
